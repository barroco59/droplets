###unix 5种 I/O模型
1. 阻塞I/O
    进程等待I/O数据的到来，调用系统调用，切换到内核状态，等I/O事件发生之后（或者发生错误，如信号中断）,程序才会切换回来。
    I/O数据到来后，数据被从内核拷贝到用户空间，进程同时会被唤醒

2. 非阻塞I/O
   该状态下，当进程等待I/O事件发生时，并不是让进程进入睡眠，而是返回一个错误。即进程调用获取I/O数据的系统调用，当I/O数据未满足条件时，内核自动返回一个错误，并不会中断程序的运行。

3. I/O复用(select/poll)
进程受阻于select、poll系统调用上，等待可能多个套接字中的任意一个变为可读。
相比阻塞I/O，select模式的优势在于可以同时等待多个I/O事件的任意一个发生。
当然还有一种I/O复用方式：fork进程或者启用多线程

4. 信号驱动I/O (SIGIO)
    进程可以首先开启套接字的信号驱动I/O功能，并通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，进程继续工作，不会被阻塞。当数据准备好时，内核就为该进程产生一个SIGIO信号。进程即被通知I/O事件的ready,进程需要处理该信号，处理数据。

5. 异步I/O (POSIX aio\_系列函数）
 与信号驱动I/O有很大的相似，主要区别在于，异步I/O内核会通知进程I/O操作何时完成，而信号驱动I/O是通知进程何时可以启动I/O操作。

所有5种I/O模型中，前四种的主要区别在于第一阶段(等待数据），而第二阶段(将数据从内核复制到调用者的缓冲区期间、进程阻塞与recvfrom调用)相同。异步I/O模型则在两个阶段都需处理，区别于其他4种模型

阻塞式I/O  | 非阻塞式   |  I/O复用   | 信号驱动式   |异步I/O   
发起       | 检查       |  检查      |              |
阻塞       | 检查       |阻塞       |               |
阻塞       |   就绪     | 就绪      | 通知发起      |
阻塞       |阻塞        |阻塞        | 阻塞         |
完成       |完成        |完成        |完成          |通知



